<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>x_441902_task_ac.TaskCounter</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description>This script include manages all the server logic for the Task Counter functionality.&#13;
&#13;
You can initialize this object without any parameters, and then use the following methods:&#13;
&#13;
var Counter = new TaskCounter();&#13;
counter.setUser(GlideRecord);&#13;
&#13;
var Counter = new TaskCounter(GlideRecord);&#13;
&#13;
If you do not specify any parameters the isBatch will be the default type.&#13;
&#13;
Once you've set the user, you can then call the method:&#13;
counter.getTotalByAssignee();&#13;
&#13;
If you have not set the user, you can then call the method:&#13;
 counter.getTotalForAll();</description>
        <name>TaskCounter</name>
        <script><![CDATA[var TaskCounter = Class.create();

// *********************************************************************************
// INTERNAL API
// *********************************************************************************

var TABLES = {
	TASK: "task",
	USER: "sys_user"
};

var PROPS = {
	PAYLOAD_MAP: "x_441902_task_ac.payload.mapping",
	ENABLED: "x_441902_task_ac.enable",
	FIELD_STYLE: "x_441902_task_ac.field_form_style.enable",
	THRESHOLD_LOW: "x_441902_task_ac.assigned_to.threshold.low",
	THRESHOLD_MEDIUM: "x_441902_task_ac.assigned_to.threshold.medium"
};

var THRESHOLDS = {
	LOW: parseInt(gs.getProperty(PROPS.THRESHOLD_LOW, 10)),
	MEDIUM: parseInt(gs.getProperty(PROPS.THRESHOLD_MEDIUM, 20))
};

var FIELDS = {
	RAW_PAYLOAD: "x_441902_task_ac_raw_assignment_payload",
	SUMMARY: "x_441902_task_ac_task_assignment_summary",
	ASSIGNED_TO: "assigned_to"
};

var USER_QUERY = "roles=itil^active=true^NQx_441902_task_ac_raw_assignment_payloadISNOTEMPTY";

var isValidGR = function (obj, table) {
	if (obj && table && (obj instanceof GlideRecord)) {
		if (obj.getTableName() === table) {
			return obj.isValidRecord();
		}
	}
	return false;
};

var getAllUsers = function () {
	var users = new GlideRecord(TABLES.USER);
	users.addEncodedQuery(USER_QUERY);
	users.query();
	return users;
};

var isEnabled = function () {
	return (gs.getProperty(PROPS.ENABLED, "false") === "true")
		? true 
		: false;
};

var isFieldStyleEnabled = function () {
	return (gs.getProperty(PROPS.FIELD_STYLE, "false") === "true")
		? true 
		: false;
};

var isAttributeValid = function (obj, attr) {
	if (!obj || !attr) {
		return false;
	}
	if (Object.keys(obj).indexOf(attr) > -1) {
		return true;
	}
	return false;
};

var isValidTable = function (table) {
	var propValue = gs.getProperty(PROPS.PAYLOAD_MAP);
	if (!propValue || !table) {
		return false;
	}
	return isAttributeValid(JSON.parse(propValue), table);
};

var getListTables = function () {
	var propValue = gs.getProperty(PROPS.PAYLOAD_MAP);
	if (!propValue) {
		return [];
	}
	return Object.keys(JSON.parse(propValue));
};

// *********************************************************************************
// EXTERNAL API
// *********************************************************************************

TaskCounter.isEnabled = isEnabled;
TaskCounter.isFieldStyleEnabled = isFieldStyleEnabled;
TaskCounter.isValidTable = isValidTable;

TaskCounter.PROPS = PROPS;
TaskCounter.FIELDS = FIELDS;
TaskCounter.TABLES = TABLES;
TaskCounter.THRESHOLDS = THRESHOLDS;

TaskCounter.prototype = {
	
    /* 
     * We initiate all the necessary attributes and throw an exception if no mapping table
	 *
     * @author Lucas Rivetti Guerino
     *
	 * @parm userRecord (GlideRecord): Valid GlideRecord pointing to the sys_user table
     * @return (void)
     */
	initialize: function (userRecord) {
		
		// In case the userRecord is not passed in we default to a batch process and abort
		if (gs.nil(userRecord)) {
			this.setBatch(true);
			return;
		}
		
		// Now we know we have a GlideRecord object
		// The setUser method will double-check whether it's a valid GlideRecord
		this.setUser(userRecord);

		// The mapping global property might have been wiped out so we check
		if (getListTables().length === 0) {
			throw new Error (
				"[" + this.type + "] - [initialize] - " +
				"The property [" + PROPS.PAYLOAD_MAP + "] does not have any table specified. " +
				"Please follow the instructions on the property description."
			);
		}
	},

	/* 
     * Set the internal attribute this.user to the value passed in
	 * If the value passed in isn't a valid user GlideRecord, exception is raised
	 *
     * @author Lucas Rivetti Guerino
     *
	 * @parm value (GlideRecord): Valid GlideRecord pointing to the sys_user table
     * @return (void)
     */
	setUser: function (value) {
		this.setBatch(false);
		if (isValidGR(value, TABLES.USER)) {
			this.user = value;
			return;
		}
		throw new Error(
			"[" + this.type + "] - [setUser] - "+
			"Unable to set user as a GlideRecord object"
		);
	},

	/* 
     * Set the internal attribute this.isBatch to the value passed in
	 *
     * @author Lucas Rivetti Guerino
     *
	 * @parm value (boolean)
     * @return (void)
     */
    setBatch: function (value) {
        this.isBatch = value;
    },

	/* 
	 * Counts the number of tasks assigned to a given user
	 *
     * @author Lucas Rivetti Guerino
     *
	 * @param table (string): Table name
     * @return (Stringified JSON)
	   The user sys id is the parent oject and the table names are attributes of the parent object
		{
			"681b365ec0a80164000fb0b05854a0cd": {
				"change_request": "5",
				"incident": "17",
				"incident_alert_task": "9",
				"problem": "9"
			}
		}
     */
	getTotalByAssignee: function (table) {
		try {
			var output = {};
			var count = 0;
			var tasks = new GlideAggregate(TABLES.TASK);
			tasks.addAggregate("COUNT", FIELDS.ASSIGNED_TO);
			tasks.addQuery("assigned_to", this.user.getUniqueValue());
			tasks.addNotNullQuery(FIELDS.ASSIGNED_TO);
			tasks.addQuery("active", true);
			if (table) {
				tasks.addQuery("sys_class_name", table);
				if (table === "incident") {
					tasks.addQuery("state", "IN", "1,2,8");
				}
			} else {
				tasks.addQuery("sys_class_name", "IN", getListTables());
			}
			tasks.groupBy("sys_class_name");
			tasks.query();
			if (!tasks.hasNext()) {
				return "";
			}
			output[this.user.getUniqueValue()] = {};
			while (tasks.next()) {
				count = tasks.getAggregate("COUNT", FIELDS.ASSIGNED_TO);
				output[this.user.getUniqueValue()][tasks.getValue("sys_class_name")] = {};
				output[this.user.getUniqueValue()][tasks.getValue("sys_class_name")] = count;
			}
			return JSON.stringify(output);
		} catch (error) {
			throw new Error(
				"[" + this.type + "] - [getTotalByAssignee] - " +
				"[Runtime error]: " + error
			);
		}
	},
	
	/* 
	 * Counts the number of tasks assigned to all users defined in the query USER_QUERY
	 * This function only runs if the isBatch is true
	 *
     * @author Lucas Rivetti Guerino
     *
	 * @param table (string): Table name
     * @return (Stringified JSON)
     */
	getTotalForAll: function (table) {
		var arrayOutput = [];
		var output = {};
		var users = {};
		if (!this.isBatch) {
			gs.warn(
				"[" + this.type + "] - [getTotalForAll] - " +
				"The isBatch attribute is false so function cannot run"
			);
			return;
		}
		users = getAllUsers();
		if (!users.hasNext()) {
			gs.warn(
				"[" + this.type + "] - [getTotalForAll] - " +
				"No users found by running query:\n" + users.getEncodedQuery()
			);
			return;
		}
		while (users.next()) {
			try {
				this.setUser(users);
				output = JSON.parse(this.getTotalByAssignee(table));
				// We ignore objects that do not have any attributes.
				// The attributes of these objects are the name of the task tables
				// If the user is not assigned to any of these tables then we don't want to return
				if (Object.keys(output[this.user.getUniqueValue()]).length === 0) {
					continue;
				}
				arrayOutput.push(output);
			} catch (error) {
				continue;
			}
		}
		return JSON.stringify(arrayOutput);
	},
	
	/* 
	 * Wipes out the payload fields on the sys_user table
	 * We run the query using the USER_QUERY internal attribute
	 *
     * @author Lucas Rivetti Guerino
     *
     * @return (void)
     */
	resetFields: function () {
		var users = {};
		if (!this.isBatch) {
			return;
		}
		users = getAllUsers();
		while (users.next()) {
			users.setValue(FIELDS.RAW_PAYLOAD, "");
			users.setValue(FIELDS.SUMMARY, "");
			users.update();
		}
	},

    type: "TaskCounter"
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2020-02-28 13:40:17</sys_created_on>
        <sys_id>ae798df42f9b00107d7d59a72799b6ef</sys_id>
        <sys_mod_count>99</sys_mod_count>
        <sys_name>TaskCounter</sys_name>
        <sys_package display_value="Task Assignment Counter " source="x_441902_task_ac">19d84d382f9b00107d7d59a72799b652</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="Task Assignment Counter ">19d84d382f9b00107d7d59a72799b652</sys_scope>
        <sys_update_name>sys_script_include_ae798df42f9b00107d7d59a72799b6ef</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2020-03-11 18:35:43</sys_updated_on>
    </sys_script_include>
</record_update>
